name: DS_HUD

slots:
    core:
        class: CoreUnit
    gyro:
        class: GyroUnit
    screen:
        class: ScreenUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    se_extrasmall:
        class: SpaceEngineExtraSmallGroup
    se_small:
        class: SpaceEngineSmallGroup
    se_medium:
        class: SpaceEngineMediumGroup
    se_large:
        class: SpaceEngineLargeGroup
    se_extralarge:
        class: SpaceEngineExtraLargeGroup

handlers:
    library:
        onStart:
            lua: |
                json = require('dkjson')
                atlas = require('atlas')
                -- CONSTANTS ----------
                constants = {}
                constants.deg2rad = 0.0174532925199
                constants.rad2deg = 57.2957795130
                constants.epsilon = 0.000001
                constants.m2kph = 3.6
                constants.kph2m = 0.27777777777
                constants.g = 9.80665

                -- HELPER -------------
                function clamp(val, min, max)
                    if val > max then
                        val = max
                    elseif val < min then
                        val = min
                    end
                    return val
                end

                function getSurfaceDirection()
                    local F = vec3(construct.getWorldOrientationForward())
                    local up = -vec3(core.getWorldVertical())
                    local forward = F
                    forward = forward - forward:project_on(up)
                    local north = vec3(0, 0, 1)
                    north = north - north:project_on(up)
                    local east = north:cross(up)
                    local angle = north:angle_between(forward) * constants.rad2deg
                    if forward:dot(east) < 0 then
                        angle = math.floor((360 - angle) * 10) / 10
                    end
                end

                function sendData2Screen(screen, data)
                    screen.setScriptInput(json.encode(data))
                end

                function getDataFromScreen(screen)
                    data = json.decode(screen.getScriptOutput()) or {}
                    screen.clearScriptOutput()
                    return data
                end

                function parseWaypoint(waypoint)
                    local n = '*([+-]?%d+%.?%d*e?[+-]?%d*)'
                    local pattern = '::pos{' .. n .. ',' .. n .. ',' .. n .. ',' .. n .. ',' .. n .. '}'
                    local systemId, bodyId, latitude, longitude, altitude = string.match(waypoint, pattern)
                    local w = {
                        systemId = tonumber(systemId),
                        bodyId = tonumber(bodyId),
                        latitude = tonumber(latitude),
                        longitude = tonumber(longitude),
                        altitude = tonumber(altitude)
                    }
                    return w
                end

                -- calculates time to burn needed to reach to desiredSpeed
                function calculateBurnTime(currentVelocity, desiredVelocity, shipMass, deltaV, thrust)

                end

                function getFuelPercentage(tanks, number_of_tanks)
                    local currentVolume = 0
                    local maxVolume = tanks[1].getMaxVolume() * number_of_tanks
                    for i = 1, number_of_tanks do
                        currentVolume = currentVolume + tanks[i].getItemsVolume()
                    end
                    return currentVolume * 100 / maxVolume
                end

                function getDeg2north()
                    local F = vec3(construct.getWorldOrientationForward())
                    local up = -vec3(core.getWorldVertical())
                    local forward = F
                    forward = forward - forward:project_on(up)
                    local north = vec3(0, 0, 1)
                    north = north - north:project_on(up)
                    local east = north:cross(up)
                    local angle = north:angle_between(forward) * constants.rad2deg
                    if forward:dot(east) < 0 then
                        angle = math.floor((360 - angle) * 10) / 10
                    end
                    return angle
                end

                function getFuelFlowRate(fuelConsumption, fuelWeight)
                    return fuelConsumption * fuelWeight
                end

                function getIsp(thrust, fuelFlowRate)
                    return thrust / (fuelFlowRate * constants.g) * 3600
                end

                function getExhaustVelocity(Isp)
                    return Isp * constants.g
                end

                function getDeltaV(shipMass, shipDryMass, Isp)
                    return Isp * constants.g * math.log(shipMass / shipDryMass)
                end

                engines = {}
                engines.space = {}
                engines.space.extrasmall = {}
                engines.space.extrasmall.number = 0
                engines.space.small = {}
                engines.space.small.number = 0
                engines.space.medium = {}
                engines.space.medium.number = 0
                engines.space.large = {}
                engines.space.large.number = 0
                engines.space.extralarge = {}
                engines.space.extralarge.number = 0

                function collectEngines()
                    local elementIdList = core.getElementIdList()
                    for i, id in ipairs(elementIdList) do
                        local class = core.getElementClassById(id):lower()
                        local spacePattern = 'spaceengine([a-z]+)group'
                        if (class:find("spaceengine")) then
                            local m = string.match(class, spacePattern)
                            engines.space[m].number = engines.space[m].number + 1
                            if engines.space[m].engine == nil then
                                engines.space[m].engine = unit["se_" .. m]
                            end
                        end
                    end
                end

                function wp2world(waypoint)
                    local wp = {}
                    if next(waypoint) ~= nil then
                        if waypoint.bodyId == 0 then
                            return vec3(waypoint.latitude, waypoint.longitude, waypoint.altitude)
                        end
                        local body = atlas[waypoint.systemId][waypoint.bodyId]
                        local latitude  = constants.deg2rad*clamp(waypoint.latitude, -90, 90)
                        local longitude = constants.deg2rad*(waypoint.longitude % 360)
                        local xproj = math.cos(latitude)
                        wp = vec3(body.center) + (body.radius + waypoint.altitude) * vec3(xproj * math.cos(longitude), xproj * math.sin(longitude), math.sin(latitude))
                    end
                    return {wp:unpack()}
                end

                -- PID ----------------
                Pid = {}
                Pid.__index = Pid

                function Pid.new(system, kp, ki, kd, sMin, sMax)
                    local self = setmetatable({}, Pid)
                    self.system = system
                    self.p = 0
                    self.i = 0
                    self.d = 0
                    self.kp = kp
                    self.ki = ki
                    self.kd = kd
                    self.sMin = sMin
                    self.sMax = sMax
                    self.prevP = 0
                    self.signal = 0
                    self.setpoint = 0
                    self.lastTime = self.system.getUtcTime()
                    return self
                end

                function Pid.update(f, setPoint, value)
                    local time = f.system.getUtcTime()
                    local timeDelta = time - f.lastTime
                    f.lastTime = time
                    f.setpoint = setPoint
                    f.p = setPoint - value
                    if (f.kd ~= 0) then
                        f.d = (f.p - f.prevP) / timeDelta
                    else
                        f.d = 0
                    end
                    if (f.ki ~= 0) then
                        f.i = f.i + f.p * timeDelta
                    else
                        f.i = 0
                    end
                    f.prevP = f.p
                    f.signal = f.p * f.kp + f.i * f.ki + f.d * f.kd
                    f.signal = clamp(f.signal, f.sMin, f.sMax)
                end

                function Pid.reset(f)
                    f.p = 0
                    f.i = 0
                    f.d = 0
                    f.signal = 0
                    f.prevValue = 0
                end

                function getTrimmedAltitude()
                    local planetId = core.getCurrentPlanetId()
                    return core.getAltitude() - atlas[0][planetId].surfaceAverageAltitude
                end

                function stabUpdate(stabToggle, pitch, roll, pitchInput, rollInput, pitchPid, rollPid)
                    if stabToggle > 0 then
                        if pitchInput ~= 0 then
                            pitchPid:reset()
                        else
                            pitchPid:update(0, pitch)
                        end

                        if rollInput ~= 0 then
                            rollPid:reset()
                        else
                            rollPid:update(0, -roll)
                        end
                    else
                        pitchPid:reset()
                        rollPid:reset()
                    end
                end

    unit:
        onStart:
            lua: |

                -- DS ===============================================================================================================
                local pitch_kP = 0.2 --export: Pitch PID koef
                local pitch_kI = 0.0001 --export: Pitch PID koef
                local pitch_kD = 0.3 --export: Pitch PID koef
                local roll_kP = 0.2 --export: Roll PID koef
                local roll_kI = 0.0001 --export: Roll PID koef
                local roll_kD = 0.3 --export: Roll PID koef

                -- collecting engines
                collectEngines()

                -- VARS
                waypoint = {} -- waypoint which you get from lua input

                for i, val in ipairs(construct.getMaxThrustAlongAxis("space_engine", construct.getForward())) do
                    system.print("index: "..i.." val:"..val)
                end
                system.print("----")
                for i, val in ipairs(unit.getEngineThrust("space_engine")) do
                    system.print("index: "..i.." val:"..val)
                end

                system.print("small: "..engines.space.small.number)
                system.print("medium: "..engines.space.medium.number)
                system.print("large: "..engines.space.large.number)

                system.print(engines.space.large.engine.getMaxThrust())

                -- PID
                pitchPid = Pid.new(system, pitch_kP, pitch_kI, pitch_kD, -1, 1)
                rollPid = Pid.new(system, roll_kP, roll_kI, roll_kD, -1, 1)

                -- Input reset
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, { 2000, 5000, 10000, 20000, 30000 })
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                screen.setRenderScript([[local json = require('dkjson')
                local vec3 = require('cpml/vec3')
                local constants = require('cpml/constants')

                -- helper functions ---
                function getData()
                    return json.decode(getInput()) or {}
                end

                function sendData(data)
                    setOutput(json.encode(data))
                end

                -- Sensor button ------
                button = {}
                button.__index = button;

                function button.new(layer, x, y, width, height)
                    local self = setmetatable({}, button)
                    self.layer = layer
                    self.x = x
                    self.y = y
                    self.width = width
                    self.height = height
                    self.dColor = { 0, 0.9, 0.8, 1 }
                    self.pColor = { 1, 0.3, 0.4, 1 }
                    self.state = false

                    return self
                end

                function button.inBounds(self, x, y)
                    if x >= self.x and x <= self.x + self.width and y >= self.y and y <= self.y + self.height then
                        return true
                    end
                    return false
                end

                function button.setState(self, state)
                    self.state = state
                end

                function button.getState(self)
                    return self.state
                end

                function button.toggle(self)
                    self.state = not self.state
                end

                function button.draw(self)
                    local color = self.dColor
                    if self.state then
                        color = self.pColor
                    end
                    setNextFillColor(self.layer, color[1], color[2], color[3], color[4])
                    addBox(self.layer, self.x, self.y, self.width, self.height)
                end

                -- HUD ----------------
                HUD = {}
                HUD.__index = HUD;

                function HUD.new(layer, layer2, layer3, f_xs, f_s, f_m, b_t, sw, sh)
                    local f = setmetatable({}, HUD)
                    f.layer = layer
                    f.layer2 = layer2
                    f.layer3 = layer3
                    f.f_xs = f_xs
                    f.f_s = f_s
                    f.f_m = f_m
                    f.b_t = b_t
                    f.sw, f.sh = sw, sh
                    f.stabBtn = button.new(f.layer3, sw - 100, sh - 100, 50, 50)
                    return f
                end

                function HUD.waypoint(f, wp, lookDeltaY)
                    if next(wp) ~= nil then
                        -- draw
                        wp = vec3(wp) * 100
                        setDefaultStrokeColor(f.layer3, Shape_Line, 0, 1, 0, 1)
                        setDefaultStrokeWidth(f.layer3, Shape_Line, 1)
                        setDefaultFillColor(f.layer3, Shape_Circle, 0, 1, 0, 1)
                        if (wp.z < 0) then
                            setDefaultStrokeColor(f.layer3, Shape_Line, 1, 0, 0, 1)
                            setDefaultFillColor(f.layer3, Shape_Circle, 1, 0, 0, 1)
                        end
                        addLine(f.layer3, f.sw/2, f.sh/2 + lookDeltaY, f.sw/2 + wp.x, f.sh/2 + lookDeltaY - wp.y)
                        addCircle(f.layer3, f.sw/2 + wp.x, f.sh/2 + lookDeltaY - wp.y, 4)
                    end
                end

                function HUD.compass(f, heading, atmoDensity)
                    if atmoDensity <= 0.001 then
                        return
                    end
                    local sectors = 50
                    local deg = 70
                    local x = f.sw / 2
                    local y = -f.sh
                    local r = math.floor(f.sh + f.sh / 10.2)
                    local arc = 180 - deg * 2
                    local s = arc / sectors
                    local rad, x1, x2, y1, y2 = 0, 0, 0, 0

                    for i = 1, sectors do
                        local dd = deg + (i - 1) * s
                        if dd > 360 then
                            dd = dd - 360
                        end
                        rad = dd * constants.deg2rad
                        x1 = x + r * math.cos(rad)
                        y1 = y + r * math.sin(rad)
                        dd = deg + i * s
                        if dd > 360 then
                            dd = dd - 360
                        end
                        rad = dd * constants.deg2rad
                        x2 = x + r * math.cos(rad)
                        y2 = y + r * math.sin(rad)
                        setNextStrokeWidth(f.layer2, f.b_t)
                        setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                        addLine(f.layer2, x1, y1, x2, y2)
                    end

                    local dec = math.floor(math.floor(heading) / 10) * 10 --десятки
                    local dif = heading - dec
                    local start = deg - arc / 2
                    for i = 1, 5 do
                        local val = start + dec - i * 10 - 10
                        if val < 0 then
                            val = 360 + val
                        end
                        if val > 360 then
                            val = val - 360
                        end
                        local d = start + dif + i * 10
                        rad = d * constants.deg2rad
                        x1 = x + (r - 30) * math.cos(rad)
                        y1 = y + (r - 30) * math.sin(rad)
                        x2 = x + (r - 10) * math.cos(rad)
                        y2 = y + (r - 10) * math.sin(rad)
                        x3 = x + (r) * math.cos(rad)
                        y3 = y + (r) * math.sin(rad)
                        if d > deg + 4 and d < deg + arc - 4 then
                            setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                            setNextStrokeWidth(f.layer2, f.b_t)
                            addLine(f.layer2, x2, y2, x3, y3)
                            setNextFillColor(f.layer2, 0, 0.9, 0.8, 1)
                            if val == 360 or val == 0 then
                                addText(f.layer2, f.f_m, "N", x1, y1)
                            elseif val == 90 then
                                addText(f.layer2, f.f_m, "E", x1, y1)
                            elseif val == 180 then
                                addText(f.layer2, f.f_m, "S", x1, y1)
                            elseif val == 270 then
                                addText(f.layer2, f.f_m, "W", x1, y1)
                            else
                                setNextTextAlign(f.layer2, AlignH_Center, AlignV_Middle)
                                addText(f.layer2, f.f_s, string.format("%.0f", val), x1, y1)
                            end
                        end
                    end

                    local x40 = math.floor(f.sw / 25.6)
                    local x14 = math.floor(f.sw / 73.1)
                    local y50 = math.floor(f.sh / 12.26)
                    local y35 = math.floor(f.sh / 17.5)
                    local y20 = math.floor(f.sh / 30.65)
                    local y17 = math.floor(f.sh / 36)
                    local y3 = math.floor(f.sh / 204.3)
                    local btt = math.ceil(f.b_t / 3)
                    setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                    setNextStrokeWidth(f.layer2, btt)
                    addLine(f.layer2, x - x40, y + r + y50, x + x40, y + r + y50)
                    setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                    setNextStrokeWidth(f.layer2, btt)
                    addLine(f.layer2, x - x40, y + r + y20, x + x40, y + r + y20)
                    setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                    setNextStrokeWidth(f.layer2, btt)
                    addLine(f.layer2, x - x40, y + r + y20, x - x40, y + r + y50)
                    setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                    setNextStrokeWidth(f.layer2, btt)
                    addLine(f.layer2, x + x40, y + r + y20, x + x40, y + r + y50)
                    setNextTextAlign(f.layer2, AlignH_Center, AlignV_Middle)
                    addText(f.layer2, f.f_s, string.format("%.2f", heading), x, y + r + y35)
                    setNextFillColor(f.layer2, 0, 0.9, 0.8, 1)
                    addTriangle(f.layer2, x, y + r + y3, x - x14, y + r + y17, x + x14, y + r + y17)
                end

                function HUD.artificialHorizon(f, pitch, roll, lookDeltaY, velocityProjX, velocityProjY, atmoDensity)
                    setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                    setDefaultStrokeWidth(f.layer, Shape_Line, 1)
                    local horizonLineLength = 100
                    local rollLineLength = 50
                    local pitchDistance = 100
                    local shipCircleRadius = 10
                    local pitchY = pitchDistance * math.sin(pitch * constants.deg2rad)

                    setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                    -- ship right wing
                    addLine(f.layer, f.sw / 2 + shipCircleRadius, f.sh / 2 + lookDeltaY, f.sw / 2 + rollLineLength, f.sh / 2 + lookDeltaY)
                    -- ship left wing
                    addLine(f.layer, f.sw / 2 - shipCircleRadius, f.sh / 2 + lookDeltaY, f.sw / 2 - rollLineLength, f.sh / 2 + lookDeltaY)

                    setNextFillColor(f.layer, 0, 0.9, 0.8, 1)
                    addCircle(layer, f.sw / 2, f.sh / 2 + lookDeltaY, shipCircleRadius)
                    setNextFillColor(f.layer, 0, 0, 0, 1)
                    addCircle(layer, f.sw / 2, f.sh / 2 + lookDeltaY, shipCircleRadius - 2)
                    setNextFillColor(f.layer, 0, 0.9, 0.8, 1)
                    local vX = f.sw / 2 + velocityProjX
                    local vY = f.sh / 2 + lookDeltaY + velocityProjY
                    if vX > f.sw - 100 then
                        vX = f.sw - 100
                    end
                    if vX < 100 then
                        vX = 100
                    end
                    if vY > f.sh - 100 then
                        vY = f.sh - 100
                    end
                    if vY < 100 then
                        vY = 100
                    end
                    addCircle(f.layer, vX, vY, 3)

                    if atmoDensity < 0.001 then
                        return
                    end

                    -- horizon =============================================================================
                    local decimal = math.floor(pitch / 10) * 10
                    local pitchDecimalDelta = pitch - decimal
                    local ratio = f.sh * 5 / 180
                    local step = 10 -- degree
                    local pitchStart = pitch
                    local degreeMargin = 20

                    for i = 0, 18 do
                        local count = pitch - step * 9 + i * step
                        local r = count * f.sh / 180

                        -- calculate starting point with offset
                        local sX = f.sw / 2 + r * math.cos((roll + 90) * constants.deg2rad)
                        local sY = (f.sh / 2 + lookDeltaY) + r * math.sin((roll + 90) * constants.deg2rad)

                        -- calculate right winged pitch lines
                        local x = sX + horizonLineLength * math.cos(roll * constants.deg2rad)
                        local y = sY + horizonLineLength * math.sin(roll * constants.deg2rad)
                        local tx = sX + (horizonLineLength + degreeMargin) * math.cos(roll * constants.deg2rad)
                        local ty = sY + (horizonLineLength + degreeMargin) * math.sin(roll * constants.deg2rad)
                        -- calculate left winged pitch lines
                        local x2 = sX - horizonLineLength * math.cos(roll * constants.deg2rad)
                        local y2 = sY - horizonLineLength * math.sin(roll * constants.deg2rad)
                        local tx2 = sX - (horizonLineLength + degreeMargin) * math.cos(roll * constants.deg2rad)
                        local ty2 = sY - (horizonLineLength + degreeMargin) * math.sin(roll * constants.deg2rad)

                        local val = (count - pitch) * -1

                        -- draw
                        if math.abs(val) < 8 then
                            val = 0
                            setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                            setDefaultFillColor(f.layer, Shape_Text, 0, 0.9, 0.8, 1)
                        else
                            setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 0.6)
                            setDefaultFillColor(f.layer, Shape_Text, 0, 0.9, 0.8, 0.6)
                        end
                        addLine(f.layer, sX, sY, x, y)
                        addLine(f.layer, sX, sY, x2, y2)

                        -- calculating degree number position
                        setDefaultTextAlign(f.layer, AlignH_Center, AlignV_Middle)
                        addText(f.layer, f.f_s, string.format("%.0f", val), tx, ty)
                        addText(f.layer, f.f_s, string.format("%.0f", val), tx2, ty2)
                    end

                    -- hide what we don't want to see
                    setNextFillColor(f.layer2, 0, 0, 0, 1)
                    local hideBoxHeight = math.floor(f.sh / 5.3)
                    local hideBoxWidth = math.floor(f.sw / 5)
                    addBox(f.layer2, 0, 0, f.sw, hideBoxHeight)
                    setNextFillColor(f.layer2, 0, 0, 0, 1)
                    addBox(f.layer2, 0, f.sh - hideBoxHeight, hideBoxWidth, f.sh)
                    setNextFillColor(f.layer2, 0, 0, 0, 1)
                    addBox(f.layer2, f.sw - hideBoxWidth, f.sh - hideBoxHeight, f.sw, f.sh)
                    -- =====================================================================================
                end

                function HUD.loop(f)
                    -- update
                    local cx, cy = getCursor()
                    local data = getData()

                    if f.stabBtn:inBounds(cx, cy) then
                        if getCursorReleased() then
                            f.stabBtn:toggle()
                        end
                    end

                    -- draw
                    f.stabBtn:draw()
                    setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                    setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                    addText(f.layer3, f.f_m, string.format("ALT %.2f", data.alt), f.sw - 50, f.sh - 150)

                    local color = { 0, 0.9, 0.8, 1 }
                    if f.stabBtn:getState() then
                        color = { 1, 0.3, 0.4, 1 }
                    end

                    -- ATMO
                    setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                    setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                    addText(f.layer3, f.f_m, string.format("ATMO F: %.2f%%", data.aP), f.sw - 50, f.sh - 220)

                    -- SPACE
                    setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                    setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                    addText(f.layer3, f.f_m, string.format("SPACE F: %.2f%%", data.sP), f.sw - 50, f.sh - 200)

                    setNextFillColor(f.layer3, color[1], color[2], color[3], color[4])
                    setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                    addText(f.layer3, f.f_m, "STAB", f.sw - 50, f.sh - 120)

                    f:compass(data.cmp, data.aD)
                    f:artificialHorizon(data.pitch, data.roll, -60, data.vPX, data.vPY, data.aD)
                    f:waypoint(data.wp, -60)

                    -- prepare data for unit
                    data = {}
                    if f.stabBtn:getState() then
                        data.stab = 1
                    else
                        data.stab = 0
                    end
                    sendData(data)
                end

                layer = createLayer()
                layer2 = createLayer()
                layer3 = createLayer()
                sw, sh = getResolution()
                baseFontSize = math.floor(sh / 40)
                baseThick = math.floor(sh / 204.3)
                font_xs = loadFont("RobotoMono-Bold", baseFontSize)
                font_s = loadFont("RobotoCondensed", baseFontSize + 4)
                font_m = loadFont("RobotoMono-Bold", baseFontSize + 6)

                if not init then
                    init = true
                    hud = HUD.new(layer, layer2, layer3, font_xs, font_s, font_m, baseThick, sw, sh)
                end

                -- main loop
                hud:loop()

                requestAnimationFrame(1)]])

        onStop:
            lua: |
                core.hideWidget()
                unit.switchOffHeadlights()

    system:
        onFlush:
            lua: |
                local pitchSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + pitchPid.signal + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + rollPid.signal + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                        + finalRollInput * rollSpeedFactor * constructForward
                        + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0, currentRollDegAbs - 30, currentRollDegAbs + 30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = -currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                + turnAssistPitchInput * constructRight
                                + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags, axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                            Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < -Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags, axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags, axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        onUpdate:
            lua: |
                local pitch = gyro.getPitch()
                local roll = gyro.getRoll()
                local atmoDensity = unit.getAtmosphereDensity()

                -- collecting data from screen
                local data = getDataFromScreen(screen)
                local stab = data.stab or 0
                screen.clearScriptOutput()
                -- ----

                stabUpdate(stab, pitch, roll, pitchInput, rollInput, pitchPid, rollPid)

                local vel = vec3.new(construct.getVelocity())
                --local speed = vel:len() * 3.6
                --local burnSpeed = 20

                Nav:update()

                local w = {}
                if next(waypoint) ~= nil then
                    local wpPos = vec3(wp2world(waypoint))
                    local pos = vec3(construct.getWorldPosition())
                    local path = vec3(wpPos - pos):normalize()
                    local up = vec3(construct.getWorldOrientationUp())
                    local right = vec3(construct.getWorldOrientationRight())
                    local forward = vec3(construct.getWorldOrientationForward())

                    w = {
                        path:dot(right),
                        path:dot(up),
                        path:dot(forward)
                    }
                end

                -- pack data for screen
                data = {
                    wp = w,
                    alt = getTrimmedAltitude(),
                    pitch = pitch,
                    roll = roll,
                    cmp = getDeg2north(),
                    aD = atmoDensity,
                    vPX = vel.x * 1,
                    vPY = -vel.z * 1,
                    aP = getFuelPercentage(atmofueltank, atmofueltank_size),
                    sP = getFuelPercentage(spacefueltank, spacefueltank_size)
                }
                sendData2Screen(screen, data)

        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end

        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() == 1 then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        onActionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        onActionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        onActionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        onActionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        onActionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        onActionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        onActionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        onActionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        onActionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        onActionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        onActionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        onActionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        onActionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        onInputText(text):
           lua: |
                local T = text
                local check = string.find(T, "::pos")
                if check then
                    -- parse
                    waypoint = parseWaypoint(T) or {}
                    system.print(string.format("Got WP: ::pos{%d,%d,%s,%s,%s}\n", waypoint.systemId, waypoint.bodyId, waypoint.latitude, waypoint.longitude, waypoint.altitude))
                end
