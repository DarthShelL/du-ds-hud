name: DS_HUD

slots:
    core:
        class: CoreUnit
    gyro:
        class: GyroUnit
    screen:
        class: ScreenUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all

handlers:
    library:
        onStart:
            lua: |
                local json = require('dkjson')
                local constants = require('cpml/constants')

                -- HELPER -------------
                function clamp(val, min, max)
                    if val > max then
                        val = max
                    elseif val < min then
                        val = min
                    end
                    return val
                end

                function getSurfaceDirection()
                    local F = vec3(construct.getWorldOrientationForward())
                    local up = -vec3(core.getWorldVertical())
                    local forward = F
                    forward = forward - forward:project_on(up)
                    local north = vec3(0, 0, 1)
                    north = north - north:project_on(up)
                    local east = north:cross(up)
                    local angle = north:angle_between(forward) * constants.rad2deg
                    if forward:dot(east) < 0 then
                        angle = math.floor((360 - angle) * 10) / 10
                    end
                end

                function sendData2Screen(screen, data)
                    screen.setScriptInput(json.encode(data))
                end

                function getDataFromScreen(screen)
                    data = json.decode(screen.getScriptOutput()) or {}
                    screen.clearScriptOutput()
                    return data
                end

                -- PID ----------------
                Pid = {}
                Pid.__index = Pid;

                function Pid.new(system, kp, ki, kd, sMin, sMax)
                    local self = setmetatable({}, Pid)
                    self.system = system
                    self.p = 0
                    self.i = 0
                    self.d = 0
                    self.kp = kp
                    self.ki = ki
                    self.kd = kd
                    self.sMin = sMin
                    self.sMax = sMax
                    self.prevP = 0
                    self.signal = 0
                    self.setpoint = 0
                    self.lastTime = self.system.getUtcTime()
                    return self
                end

                function Pid.update(f, setPoint, value)
                    local time = f.system.getUtcTime()
                    local timeDelta = time - f.lastTime
                    f.lastTime = time
                    f.setpoint = setPoint
                    f.p = setPoint - value
                    if (f.kd ~= 0) then
                        f.d = (f.p - f.prevP) / timeDelta
                    else
                        f.d = 0
                    end
                    if (f.ki ~= 0) then
                        f.i = f.i + f.p * timeDelta
                    else
                        f.i = 0
                    end
                    f.prevP = f.p
                    f.signal = f.p * f.kp + f.i * f.ki + f.d * f.kd
                    f.signal = clamp(f.signal, f.sMin, f.sMax)
                end

                function Pid.reset(f)
                    f.p = 0
                    f.i = 0
                    f.d = 0
                    f.signal = 0
                    f.prevValue = 0
                end

    unit:
        onStart:
            lua: |
                local pitch_kP = 0.2 --export: Pitch PID koef
                local pitch_kI = 0.0001 --export: Pitch PID koef
                local pitch_kD = 0.3 --export: Pitch PID koef
                local roll_kP = 0.2 --export: Roll PID koef
                local roll_kI = 0.0001 --export: Roll PID koef
                local roll_kD = 0.3 --export: Roll PID koef

                altitudeTrim = 0

                -- PID
                pitchPid = Pid.new(system, pitch_kP, pitch_kI, pitch_kD, -1, 1)
                rollPid = Pid.new(system, roll_kP, roll_kI, roll_kD, -1, 1)

                -- Input reset
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, { 2000, 5000, 10000, 20000, 30000 })
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                -- category panel display helpers
                _autoconf = {}
                _autoconf.panels = {}
                _autoconf.panels_size = 0
                _autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)
                    widgetPerData = widgetPerData or false -- default to one widget for all data
                    if size > 0 then
                        local panel = system.createWidgetPanel(title)
                        local widget
                        if not widgetPerData then
                            widget = system.createWidget(panel, type)
                        end
                        for i = 1, size do
                            if widgetPerData then
                                widget = system.createWidget(panel, type)
                            end
                            system.addDataToWidget(elements[i].getWidgetDataId(), widget)
                        end
                        _autoconf.panels_size = _autoconf.panels_size + 1
                        _autoconf.panels[_autoconf.panels_size] = panel
                    end
                end
                _autoconf.hideCategoryPanels = function()
                    for i=1,_autoconf.panels_size do
                        system.destroyWidgetPanel(_autoconf.panels[i])
                    end
                end

                -- Proxy array to access auto-plugged slots programmatically
                atmofueltank = {}
                atmofueltank[1] = atmofueltank_1
                atmofueltank_size = 1

                spacefueltank = {}
                spacefueltank[1] = spacefueltank_1
                spacefueltank[2] = spacefueltank_2
                spacefueltank[3] = spacefueltank_3
                spacefueltank_size = 3
                -- End of auto-generated code

                screen.setRenderScript([[local json = require('dkjson')
                     local constants = require('cpml/constants')

                     -- helper functions ---
                     function getData()
                         return json.decode(getInput()) or {}
                     end

                     function sendData(data)
                         setOutput(json.encode(data))
                     end

                     -- Sensor button ------
                     button = {}
                     button.__index = button;

                     function button.new(layer, x, y, width, height)
                         local self = setmetatable({}, button)
                         self.layer = layer
                         self.x = x
                         self.y = y
                         self.width = width
                         self.height = height
                         self.dColor = { 0, 0.9, 0.8, 1 }
                         self.pColor = { 1, 0.3, 0.4, 1 }
                         self.state = false

                         return self
                     end

                     function button.inBounds(self, x, y)
                         if x >= self.x and x <= self.x + self.width and y >= self.y and y <= self.y + self.height then
                             return true
                         end
                         return false
                     end

                     function button.setState(self, state)
                         self.state = state
                     end

                     function button.getState(self)
                         return self.state
                     end

                     function button.toggle(self)
                         self.state = not self.state
                     end

                     function button.draw(self)
                         local color = self.dColor
                         if self.state then
                             color = self.pColor
                         end
                         setNextFillColor(self.layer, color[1], color[2], color[3], color[4])
                         addBox(self.layer, self.x, self.y, self.width, self.height)
                     end

                     -- HUD ----------------
                     HUD = {}
                     HUD.__index = HUD;

                     function HUD.new(layer, layer2, layer3, f_xs, f_s, f_m, b_t, sw, sh)
                         local f = setmetatable({}, HUD)
                         f.layer = layer
                         f.layer2 = layer2
                         f.layer3 = layer3
                         f.f_xs = f_xs
                         f.f_s = f_s
                         f.f_m = f_m
                         f.b_t = b_t
                         f.sw, f.sh = sw, sh
                         f.stabBtn = button.new(f.layer3, sw - 100, sh - 100, 50, 50)
                         return f
                     end

                     function HUD.compass(f, heading, atmoDensity)
                         if atmoDensity <= 0.001 then
                             return
                         end
                         local sectors = 50
                         local deg = 70
                         local x = f.sw / 2
                         local y = -f.sh
                         local r = math.floor(f.sh + f.sh / 10.2)
                         local arc = 180 - deg * 2
                         local s = arc / sectors
                         local rad, x1, x2, y1, y2 = 0, 0, 0, 0

                         for i = 1, sectors do
                             local dd = deg + (i - 1) * s
                             if dd > 360 then
                                 dd = dd - 360
                             end
                             rad = dd * constants.deg2rad
                             x1 = x + r * math.cos(rad)
                             y1 = y + r * math.sin(rad)
                             dd = deg + i * s
                             if dd > 360 then
                                 dd = dd - 360
                             end
                             rad = dd * constants.deg2rad
                             x2 = x + r * math.cos(rad)
                             y2 = y + r * math.sin(rad)
                             setNextStrokeWidth(f.layer2, f.b_t)
                             setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                             addLine(f.layer2, x1, y1, x2, y2)
                         end

                         local dec = math.floor(math.floor(heading) / 10) * 10 --десятки
                         local dif = heading - dec
                         local start = deg - arc / 2
                         for i = 1, 5 do
                             local val = start + dec - i * 10 - 10
                             if val < 0 then
                                 val = 360 + val
                             end
                             if val > 360 then
                                 val = val - 360
                             end
                             local d = start + dif + i * 10
                             rad = d * constants.deg2rad
                             x1 = x + (r - 30) * math.cos(rad)
                             y1 = y + (r - 30) * math.sin(rad)
                             x2 = x + (r - 10) * math.cos(rad)
                             y2 = y + (r - 10) * math.sin(rad)
                             x3 = x + (r) * math.cos(rad)
                             y3 = y + (r) * math.sin(rad)
                             if d > deg + 4 and d < deg + arc - 4 then
                                 setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                                 setNextStrokeWidth(f.layer2, f.b_t)
                                 addLine(f.layer2, x2, y2, x3, y3)
                                 setNextFillColor(f.layer2, 0, 0.9, 0.8, 1)
                                 if val == 360 or val == 0 then
                                     addText(f.layer2, f.f_m, "N", x1, y1)
                                 elseif val == 90 then
                                     addText(f.layer2, f.f_m, "E", x1, y1)
                                 elseif val == 180 then
                                     addText(f.layer2, f.f_m, "S", x1, y1)
                                 elseif val == 270 then
                                     addText(f.layer2, f.f_m, "W", x1, y1)
                                 else
                                     setNextTextAlign(f.layer2, AlignH_Center, AlignV_Middle)
                                     addText(f.layer2, f.f_s, string.format("%.0f", val), x1, y1)
                                 end
                             end
                         end

                         local x40 = math.floor(f.sw / 25.6)
                         local x14 = math.floor(f.sw / 73.1)
                         local y50 = math.floor(f.sh / 12.26)
                         local y35 = math.floor(f.sh / 17.5)
                         local y20 = math.floor(f.sh / 30.65)
                         local y17 = math.floor(f.sh / 36)
                         local y3 = math.floor(f.sh / 204.3)
                         local btt = math.ceil(f.b_t / 3)
                         setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                         setNextStrokeWidth(f.layer2, btt)
                         addLine(f.layer2, x - x40, y + r + y50, x + x40, y + r + y50)
                         setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                         setNextStrokeWidth(f.layer2, btt)
                         addLine(f.layer2, x - x40, y + r + y20, x + x40, y + r + y20)
                         setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                         setNextStrokeWidth(f.layer2, btt)
                         addLine(f.layer2, x - x40, y + r + y20, x - x40, y + r + y50)
                         setNextStrokeColor(f.layer2, 0, 0.9, 0.8, 1)
                         setNextStrokeWidth(f.layer2, btt)
                         addLine(f.layer2, x + x40, y + r + y20, x + x40, y + r + y50)
                         setNextTextAlign(f.layer2, AlignH_Center, AlignV_Middle)
                         addText(f.layer2, f.f_s, string.format("%.2f", heading), x, y + r + y35)
                         setNextFillColor(f.layer2, 0, 0.9, 0.8, 1)
                         addTriangle(f.layer2, x, y + r + y3, x - x14, y + r + y17, x + x14, y + r + y17)
                     end

                     function HUD.artificialHorizon(f, pitch, roll, lookDeltaY, velocityProjX, velocityProjY, atmoDensity)
                         setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                         setDefaultStrokeWidth(f.layer, Shape_Line, 1)
                         local horizonLineLength = 100
                         local rollLineLength = 50
                         local pitchDistance = 100
                         local shipCircleRadius = 10
                         local pitchY = pitchDistance * math.sin(pitch * constants.deg2rad)

                         setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                         -- ship right wing
                         addLine(f.layer, f.sw / 2 + shipCircleRadius, f.sh / 2 + lookDeltaY, f.sw / 2 + rollLineLength, f.sh / 2 + lookDeltaY)
                         -- ship left wing
                         addLine(f.layer, f.sw / 2 - shipCircleRadius, f.sh / 2 + lookDeltaY, f.sw / 2 - rollLineLength, f.sh / 2 + lookDeltaY)

                         setNextFillColor(f.layer, 0, 0.9, 0.8, 1)
                         addCircle(layer, f.sw / 2, f.sh / 2 + lookDeltaY, shipCircleRadius)
                         setNextFillColor(f.layer, 0, 0, 0, 1)
                         addCircle(layer, f.sw / 2, f.sh / 2 + lookDeltaY, shipCircleRadius - 2)
                         setNextFillColor(f.layer, 0, 0.9, 0.8, 1)
                         local vX = f.sw / 2 + velocityProjX
                         local vY = f.sh / 2 + lookDeltaY + velocityProjY
                         if vX > f.sw - 100 then
                             vX = f.sw - 100
                         end
                         if vX < 100 then
                             vX = 100
                         end
                         if vY > f.sh - 100 then
                             vY = f.sh - 100
                         end
                         if vY < 100 then
                             vY = 100
                         end
                         addCircle(f.layer, vX, vY, 3)

                         if atmoDensity < 0.001 then
                             return
                         end

                         -- horizon =============================================================================
                         local decimal = math.floor(pitch / 10) * 10
                         local pitchDecimalDelta = pitch - decimal
                         local ratio = f.sh * 5 / 180
                         local step = 10 -- degree
                         local pitchStart = pitch
                         local degreeMargin = 20

                         for i = 0, 18 do
                             local count = pitch - step * 9 + i * step
                             local r = count * f.sh / 180

                             -- calculate starting point with offset
                             local sX = f.sw / 2 + r * math.cos((roll + 90) * constants.deg2rad)
                             local sY = (f.sh / 2 + lookDeltaY) + r * math.sin((roll + 90) * constants.deg2rad)

                             -- calculate right winged pitch lines
                             local x = sX + horizonLineLength * math.cos(roll * constants.deg2rad)
                             local y = sY + horizonLineLength * math.sin(roll * constants.deg2rad)
                             local tx = sX + (horizonLineLength + degreeMargin) * math.cos(roll * constants.deg2rad)
                             local ty = sY + (horizonLineLength + degreeMargin) * math.sin(roll * constants.deg2rad)
                             -- calculate left winged pitch lines
                             local x2 = sX - horizonLineLength * math.cos(roll * constants.deg2rad)
                             local y2 = sY - horizonLineLength * math.sin(roll * constants.deg2rad)
                             local tx2 = sX - (horizonLineLength + degreeMargin) * math.cos(roll * constants.deg2rad)
                             local ty2 = sY - (horizonLineLength + degreeMargin) * math.sin(roll * constants.deg2rad)

                             local val = (count - pitch) * -1

                             -- draw
                             if math.abs(val) < 8 then
                                 val = 0
                                 setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 1)
                                 setDefaultFillColor(f.layer, Shape_Text, 0, 0.9, 0.8, 1)
                             else
                                 setDefaultStrokeColor(f.layer, Shape_Line, 0, 0.9, 0.8, 0.6)
                                 setDefaultFillColor(f.layer, Shape_Text, 0, 0.9, 0.8, 0.6)
                             end
                             addLine(f.layer, sX, sY, x, y)
                             addLine(f.layer, sX, sY, x2, y2)

                             -- calculating degree number position
                             setDefaultTextAlign(f.layer, AlignH_Center, AlignV_Middle)
                             addText(f.layer, f.f_s, string.format("%.0f", val), tx, ty)
                             addText(f.layer, f.f_s, string.format("%.0f", val), tx2, ty2)
                         end

                         -- hide what we don't want to see
                         setNextFillColor(f.layer2, 0, 0, 0, 1)
                         local hideBoxHeight = math.floor(f.sh / 5.3)
                         local hideBoxWidth = math.floor(f.sw / 5)
                         addBox(f.layer2, 0, 0, f.sw, hideBoxHeight)
                         setNextFillColor(f.layer2, 0, 0, 0, 1)
                         addBox(f.layer2, 0, f.sh - hideBoxHeight, hideBoxWidth, f.sh)
                         setNextFillColor(f.layer2, 0, 0, 0, 1)
                         addBox(f.layer2, f.sw - hideBoxWidth, f.sh - hideBoxHeight, f.sw, f.sh)
                         -- =====================================================================================
                     end

                     function HUD.loop(f)
                         -- update
                         local cx, cy = getCursor()
                         local data = getData()

                         if f.stabBtn:inBounds(cx, cy) then
                             if getCursorReleased() then
                                 f.stabBtn:toggle()
                             end
                         end

                         -- draw
                         f.stabBtn:draw()
                         setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                         setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                         addText(f.layer3, f.f_m, string.format("ALT %.2f", data.altitude), f.sw - 50, f.sh - 150)

                         local color = { 0, 0.9, 0.8, 1 }
                         if f.stabBtn:getState() then
                             color = { 1, 0.3, 0.4, 1 }
                         end

                         -- ATMO
                         setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                         setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                         addText(f.layer3, f.f_m, string.format("ATMO F: %.2f%%", data.atmoPercentage), f.sw - 50, f.sh - 220)

                         -- SPACE
                         setNextFillColor(f.layer3, 0, 0.9, 0.8, 1)
                         setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                         addText(f.layer3, f.f_m, string.format("SPACE F: %.2f%%", data.spacePercentage), f.sw - 50, f.sh - 200)

                         setNextFillColor(f.layer3, color[1], color[2], color[3], color[4])
                         setNextTextAlign(f.layer3, AlignH_Right, AlignV_Middle)
                         addText(f.layer3, f.f_m, "STAB", f.sw - 50, f.sh - 120)

                         f:compass(data.compass, data.atmoDensity)
                         f:artificialHorizon(data.pitch, data.roll, -60, data.velocityProjX, data.velocityProjY, data.atmoDensity)

                         -- prepare data for unit
                         data = {}
                         if f.stabBtn:getState() then
                             data.stab = 1
                         else
                             data.stab = 0
                         end
                         sendData(data)
                     end

                     layer = createLayer()
                     layer2 = createLayer()
                     layer3 = createLayer()
                     sw, sh = getResolution()
                     baseFontSize = math.floor(sh / 40)
                     baseThick = math.floor(sh / 204.3)
                     font_xs = loadFont("RobotoMono-Bold", baseFontSize)
                     font_s = loadFont("RobotoCondensed", baseFontSize + 4)
                     font_m = loadFont("RobotoMono-Bold", baseFontSize + 6)

                     if not init then
                         init = true
                         hud = HUD.new(layer, layer2, layer3, font_xs, font_s, font_m, baseThick, sw, sh)
                     end

                     -- main loop
                     hud:loop()

                     requestAnimationFrame(1)]])

        onStop:
            lua: |
                core.hideWidget()
                unit.switchOffHeadlights()

    system:
        onFlush:
            lua: |
                local pitchSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 0.3 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + pitchPid.signal + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + rollPid.signal + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                        + finalRollInput * rollSpeedFactor * constructForward
                        + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0, currentRollDegAbs - 30, currentRollDegAbs + 30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = -currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                + turnAssistPitchInput * constructRight
                                + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags, axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                            Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < -Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags, axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags, axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        onUpdate:
            lua: |
                local pitch = gyro.getPitch()
                local roll = gyro.getRoll()
                local atmoDensity = unit.getAtmosphereDensity()

                local data = getDataFromScreen(screen)
                stab = data.stab or 0
                screen.clearScriptOutput()

                -- Planet info
                local planetId = core.getCurrentPlanetId()
                --system.print(string.format("Planet ID: %d\n", planetId))
                if planetId == 27 then
                    altitudeTrim = 200
                elseif planetId == 1 then
                    altitudeTrim = 0
                elseif planetId == 2 then
                    -- Alioth
                    altitudeTrim = 200
                elseif planetId == 3 then
                    -- Thades
                    altitudeTrim = 13690
                end

                if stab > 0 then
                    if pitchInput ~= 0 then
                        pitchPid:reset()
                    else
                        pitchPid:update(0, pitch)
                    end

                    if rollInput ~= 0 then
                        rollPid:reset()
                    else
                        rollPid:update(0, -roll)
                    end
                else
                    pitchPid:reset()
                    rollPid:reset()
                end

                local vel = vec3.new(construct.getVelocity())

                local speed = vel:len() * 3.6
                --local burnSpeed = construct.getFrictionBurnSpeed() * 3.6
                local burnSpeed = 20

                Nav:update()

                local F = vec3(construct.getWorldOrientationForward())
                local up = -vec3(core.getWorldVertical())
                local forward = F
                forward = forward - forward:project_on(up)
                local north = vec3(0, 0, 1)
                north = north - north:project_on(up)
                local east = north:cross(up)
                local angle = north:angle_between(forward) * constants.rad2deg
                if forward:dot(east) < 0 then
                    angle = math.floor((360 - angle) * 10) / 10
                end

                local atmoFuelMaxVolume = atmofueltank[1].getMaxVolume()
                local atmoFuelCurrentVolume = atmofueltank[1].getItemsVolume()
                for i=1, atmofueltank_size do
                    atmoFuelCurrentVolume = atmoFuelCurrentVolume + atmofueltank[i].getItemsVolume()
                end
                local atmoPercentage = atmoFuelCurrentVolume * 100 / atmoFuelMaxVolume
                local spaceFuelMaxVolume = spacefueltank[1].getMaxVolume() * 3
                local spaceFuelCurrentVolume = 0
                for i=1, spacefueltank_size do
                    spaceFuelCurrentVolume = spaceFuelCurrentVolume + spacefueltank[i].getItemsVolume()
                end
                local spacePercentage = spaceFuelCurrentVolume * 100 / spaceFuelMaxVolume

                -- pack data for screen
                local altitude = core.getAltitude() - altitudeTrim
                data = {
                    altitude = altitude,
                    pitch = pitch,
                    roll = roll,
                    compass = angle,
                    atmoDensity = atmoDensity,
                    velocityProjX = vel.x * 1,
                    velocityProjY = -vel.z * 1,
                    atmoPercentage = atmoPercentage,
                    spacePercentage = spacePercentage
                }

                sendData2Screen(screen, data)

        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end

        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() == 1 then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        onActionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        onActionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        onActionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        onActionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        onActionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        onActionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        onActionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        onActionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        onActionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        onActionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        onActionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        onActionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        onActionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
